# Path Planning Project - Overview of Methods

## Lane Generation
In each iteration, a set of 50 (x,y) values is sent to the simulator for moving the car. The points that were not used by the simulator in the last iteration reused for this iteration. The rest (50 - number of points not used in the last iteration) are sampled from a trajectory generated by the `spline.h` library on the following set of points:
- some points from the last iteration, for a smooth transition:
```
spline_X.push_back(previous_path_x[len_previous_path - 5]);
spline_Y.push_back(previous_path_y[len_previous_path - 5]);

spline_X.push_back(previous_path_x[len_previous_path - 1]);
spline_Y.push_back(previous_path_y[len_previous_path - 1]);
```
- some points within the same lane (or in case of lange change, the desired lane):
```
spline_X.push_back(
        getXY(cur_s + future_values[0], optimal_d, this->landmarks)[0]);
spline_Y.push_back(
        getXY(cur_s + future_values[0], optimal_d, this->landmarks)[1]);

spline_X.push_back(
        getXY(cur_s + future_values[1], optimal_d, this->landmarks)[0]);
spline_Y.push_back(
        getXY(cur_s + future_values[1], optimal_d, this->landmarks)[1]);

spline_X.push_back(
        getXY(cur_s + future_values[2], optimal_d, this->landmarks)[0]);
spline_Y.push_back(
        getXY(cur_s + future_values[2], optimal_d, this->landmarks)[1]);
```

Here, 
- `cur_s` is the end of the last iteration's generated path (or the car's s value in case of first iteration), 
- `future_values` is a vector of steps, which differs from the case where we want to change lanes (`future_values = {50, 70, 90};`), to the case where we go straight (`future_values = {13, 20, 35, 60};`). This leads to a smoother experience when changing lanes the reference points for the spline are farther away. On the other hand, the smaller distance in the case of going straight assures that the vehicle stays in it's lane.

After the spline is generated, points are generated in a way, that max acceleration of 10 m/s^2 and max jerk of 10 m/s^3 are not violated. For this some calculations lead to the constraints that 
```
double max_x_for_jerk_max = x_prev + 0.02 * 0.02 * 0.02 * jerk_max
        + 2 * dist_prev + dist_prevprev;
double max_x_for_accel_max = x_prev + dist_prev
        + 0.02 * 0.02 * accel_max;
```
where x_prev is the last generated x value.


### Avoiding to crash into slower moving car
By evaluating the sensor_fusion vector, we determine all cars that are driving close ahead of us in our lane. We then check, if we need to decelerate:
```
if (!is_in_current_lane(v.d))
			continue;
if (distance(v.x, v.y, car_x, car_y) < MIN_DISTANCE_TO_OTHERS
        && distance(car_x, car_y, v.x, v.y) < cur_min_distance
        && vehicle_is_in_front(v) && vehicle_is_slower(v))
{
```

### Change lanes
As soon as we are decelerating we need to think about chaning lanes. Therefore we set a flag to change lanes if speed is too low:

```
			if (previous_lane == -1 && cur_min_speed_mph < 45) {
				must_change_lanes = true;
				not_yet_changed_lanes = true;
			}
```
`previous_lane` is set to the previous lane. This is supposed to keep the car from immediately switching back to a lane it just came from. `previous_lane` is reset (to `-1`) after a certain amount of iterations to not block the car indefinitely.

### Check if lane change safe
As soon as we need to change lanes, we check the adjacent lanes for safe transitioning. Therefore we loop through all other vehicles and check if they're in our target lane (or close to it, in case they also area bout to shift lanes...)

```
bool PathGenerator::check_lane_safe(int lane_number) {
	Vehicle v;
	for (auto const& vehicle_map_entry : vehicles) {
		v = vehicle_map_entry.second;
		if (!is_near_same_lane(v.d, lane_number))
			continue;

		if (distance(current_path_x, current_path_y, v.x, v.y)
				< MIN_DISTANCE_TO_OTHERS_OVERTAKING
				&& !(v.s < car_s - 10 && getNorm(v.vx, v.vy) < car_speed - 5)) {
			return false;
		}
	}
	return true;
}
```

During the process of chaning lanes, another flag, `not_yet_changed_lanes` is set to `true` and only reset to `false`, if the car's `d` value has reached approximately the value corresponding to the center of the lane it wanted to transition to. This is done to prevent changing lanes forth and back during a lane change cycle.
